# 인증방식

## **API Key**

서비스들이 거대해짐 → 서비스의 각 기능등을 분리하기 시작 → 이를 위해 Module 이나 Application들간의 공유와 독립성을 보장하기위 위한 기능들이 등장

그 중 제일 먼저 등장하고 가장 보편적으로 쓰이는 기술이 **API Key** 이다.

---

### 동작방식

1. 사용자가 API Key 발급
2. 해당 API 사용을 위해 Key 함께 요청을 보냄
3. Application은 요청이 오면 Key를 통해 User 정보를 확인하여 누구의 Key인지 권한이 무엇인지를 확인
4. 해당 Key의 인증과 인가에 따라 데이터를 사용자에게 반환

### 문제점

API Key를 사용자에게 직접 발급, 해당 Key를 통해 통신하기 때문에 통신구간의 암호화가 잘 되어 있더라고 Key가 유출된 경우에 대비하기 힘들다. 때문에 주기적으로 Key를 업데이트해야 함으로 번거롭고 예기치 못한 상황이 발생할 수 있다.(업데이트가 한쪽만 되는 등등…) 또한 Key 한가지로 정보를 제어하기 때문에 보안문제가 발생하기 쉽다.

## OAuth2

API Key 의 단점을 매꾸기 위해 등장한 방식. 대표적으로 페이스북, 트우터 등 SNS 로그인기능에서 많이 볼 수 있다. 요청하고 요청받는 단순한 방식에서 인증부분이 추가되어 독립적인 세분화가 이루어진 방식이다.

---

### 동작방식

(다양한 경우가 있지만 여기서는 **로그인**의 경우)

1. 사용자가 Application의 기능을 사용하기 위한 요청을 전송.
2. Applicationd은 해당 사용자의 로그인 여부를 확인. 로그인이 되어있지 않다면 다음 단계로 넘어감.
3. Application은 사용자가 로그인 되어 있지 않으면 사용자를 인증서버로 Redirection
4. 간접적으로 Authorize 요청을 받은 인증서버는 해당 사용자가 회원인지 그리고 인증 서버에 로그인 되어있는지를 확인 

```
인증 : 너 momo 맞지?
인가 : 너 접급권한/true 맞지?
즉, 인증은 사용자가 시스템에 로그인하여 신원을 확인하는 과정,
    인가는 인증된 사용자가 특정 자원이나 기능에 대한 접근권한을 확인하는 과정.
```

1. 인증을 거쳤으면 **사용자가 최초의 요청에 대한 권한이 있는지 확인** → 이러한 과정을 **Grant** 라고 함. 대체적으로 인증서버는 사용자의 의지를 확인하는 Grant 처리를 하게 되고, 각 Application은 다시 권한을 관리할 수도 있다. 이 과정에서 사용자의 Grant가 확인 되지 않으면 다시 사용자에게 Grant 요청을 보낸다. (즉, 여기서의 권한은 서비스제공자 측의 권한이 아니라, 사용자가 자신의 개인정보를 제공할 권한이 있는지 확인하는 것이다. 권한이 없다면 보통 권한을 사용해달라고 요청한다. ex) 이메일 제공 동의에 체크해주세요 ㅜㅜ)

```
**Grant** 란?
Grant는 인가와는 다소 른 개념이다. 인가는 서비스 제공자 입장에서 사용자의 권한을 보는 것이지만,
Grant는 사용자가 자신의 인증정보(보통 개인정보 등)를 Applicaiton에 넘길지 말지 결정하는 과정.
```

1. 사용자가 Grant 요청을 받게 되면 사용자는 해당 인증정보에 대한 허가를 내려준다. 해당 요청을 통해 다시 인증서버에 인가 처리를 위해 요청을 보낸다.
2. 인증서버에서 인증과 인가가 모두 완료되면 Application에게 인가코드를 전달. 인증서버는 해당 인가코드를 자신의 저장소에 저장해둠. (해당코드는 보안을 위해 매우 짧은 기간동안만 유효함)
3. 인가코드는 짧은 시간 유지되기 때문에, 이제 Application은 해당코드를 Request Token으로 사용하여 인증서버에 요청을 보내게 된다.
4. 해당 Request Token을 받은 인증서버는 자신의 저장소에 저장한 코드(7번 과정)과 일치하는지를 확인하고, 긴 유효기간을 가지고 실제 리소스 접근에 사용하게 될 Access Token을 Application에게 전달함
5. 이제 Application은 Access Token을 통해 업무를 처리할 수 있다. 해당 Access Token을 통해 리소스 서버(인증서버 아님)에 요청을 하게 된다. 하지만 이 과정에서도 리소스 서버는 바로 데이터를 전달하는 것이 아니라, 인증서버에 연결해 해당 토큰이 유효한지 확인하는 과정을 거친다. 해당 토큰이 유효하다면 사용자는 드디어 요청한 정보를 받아 볼 수 있다.

### 문제점

많은 부분이 개선되었지만, 기존 API 방식에 비해 좀 더 구조가 복잡하다. 

통신에 이용되는 Token은 무의미한 문자열로 규칙없이 발행되기 때문에 증명이 필요하다. 때문에 인증서버에 DBMS 접근이나 API를 이용한 접근등의 유효성 확인이 필요하다는 공증 여부 문제가 있다. (즉, ‘무의미한 문자열 발행’ → 고정된 암호가 아니라 무작위 발행되는 암호이기 때문에 발행된 암호가 이게 맞는지 유효성 검사를 한번 해줘야 함) + 유효기간 문제.

## JWT

인증 흐름에 대한 규약이 아닌 Token 작성에 대한 규약. Access Token이 기본적으로는 무작위 발행되기에 검증과정을 거쳐야 하는 반면, JWT는 인증여부 확인을 위한 값, 유효성 검증을 위한 값, 인증 정보 자체를 담고 있기에 인증서버에 요청없이도 사용할 수 있음

---

[JWT란?](https://www.notion.so/JWT-6d9bf2dae30b42c0b842730670acd87f?pvs=21)

### 문제점

서버에 직접 연결하여 인증과정을 거치지 않아도 되기에 생기는 장점들이 많다. 하지만 토큰 자체가 인증 정보를 가지고 있기 때문에 민감한 정보는 인증서버에 다시 접속하는 과정이 필요하다. (토큰에 정보가 이렇게 많으면 그럼 보안은…대체…어떻게……?? →  서명(비밀키), 암호화, Https, 유효기간 등을 사용하여 보안을 유지함)

Q.  사용자의 접근 권환을 확인하는 과정은 무엇인가?

1. 인증
2. 인가

+추가문제 . 그렇다면 답이 아닌 단어는 무엇을 확인하는 과정인가?