# TCP/IP 흐름제어/혼잡제어

# 0) 공부하기 전에..

**기본 용어**

- 통신(communication) : 데이터를 주고받는 행위
- 애플리케이션(application) : 통신에 사용하는 프로그램
- 송신자(sender) : 통신에서 데이터를 전송하는 사람
- 수신자(receiver) : 통신에서 데이터를 받는 사람

**TCP란**

- TCP는 기본적으로 비신뢰적 네트워크(unreliable network)에서 신뢰적 네트워크(reliable network)를 보장할 수 있도록 하는 프로토콜.
- TCP가 보장하는 신뢰적인 데이터 전송이란 데이터가 하나도 빠짐없이 순서대로 전송되는 것을 의미함.
- 흐름제어와 혼잡제어 기능을 함.  
<br/>


# 1) 비신뢰적 네트워크

송신자가 수신자에게 데이터를 전송하는 과정을 생각해보자.

수신자는 송신자가 보낸 데이터를 순서에 맞게 하나도 빠짐없이 받아야 한다.

그러나 현실의 네트워크에서는 데이터를 잃어버리거나 데이터의 순서가 변경되는 문제가 발생함.

이를 **비신뢰적 네트워크(unreliable network)**라고 부름.
<br/>

## 비신뢰적 네트워크에서 발생하는 문제

- 손실(lost) : 패킷이 손실될 수 있는 문제
- 순서 바뀜 : 패킷의 순서가 바뀌는 문제
- 혼잡(Congestion) : 네트워크가 혼잡해질 수 있는 문제
- 과부하(Overload) : 수신자가 과부하되는 문
<br/>
# 2) 데이터 전송 과정

- 송신자가 수신자에게 데이터 전송을 시작함.
- 송신자가 데이터 전송 시 TCP에 의해 데이터 전송됨.
- 데이터는 네트워크를 통해 수신자에게 도착함.
- 도착한 데이터는 수신자의 버퍼에 저장됨.
- 수신자의 애플리케이션이 버퍼에 저장된 데이터를 읽으면 전송 완료

만약 위의 과정에서 송신자가 수신자의 데이터 처리속도보다 빠르게 전송한다면?

또한 사용하는 네트워크에 수많은 인원이 데이터를 전송해서 정체 현상이 발생한다면? 

→ 이를 해결하기 위한 방법이 바로 **흐름 제어와 혼잡제어**이다.

# 3) 흐름 제어

송신 측의 데이터 전송 속도가 수신측의 데이터 처리 속도보다 빠르다면

- 수신 측에서 제한된 저장 용량을 초과한 이후에 도착하는 패킷은 손실될 수 있음.
- 손실된 데이터는 불필요한 추가 패킷 전송으로 이어짐.

**흐름 제어는 송신자의 전송 속도와 수신자의 처리 속도의 차이에서 생기는 문제를 해결하기 위한 기능임.**

## 흐름제어의 기본 과정

1. 송신자가 수신자에게 데이터를 보냄.
2. 수신자는 송신자에게 데이터를 받을 때마다 자신의 남은 버퍼 공간을 알려줌.
3. 송신자는 수신자가 보낸 정보를 보고 데이터 전송 속도를 조절함.

## 해결방법

### **Stop and Wait**

![Untitleddddd](https://github.com/Audrey-1120/cs-study/assets/100057254/edac9335-db6f-4898-98a0-4adecf47fe71)

- 송신자가 데이터를 하나 보낼때마다 수신자의 응답을 기다림.
- 구현이 간단하지만 매우 비효율적임.

### **Sliding Window**
![123123ㅁㄴㅇㅁㄴㅇ](https://github.com/Audrey-1120/cs-study/assets/100057254/9c338c5e-b845-4919-943e-c5bd7292215c)


- 수신자가 설정한 윈도우 크기만큼 송신자가 확인응답 없이 데이터(세그먼트)를 전송할 수 있게 함.
- `LastByteSent - LastByteAcked <= ReceiveWindowAdvertised`
    - (마지막으로 보낸 바이트) - (마지막으로 확인 응답 받은 바이트) ≤ 수신 버퍼 남은 공간
    - 공중에 떠있는 패킷 수(송신자는 전송했으나 아직 확인 응답 받지 못한 데이터)가 수신자가 광고한 윈도우 크기보다 작거나 같아야 함.

**동작 방식**

- **윈도우 내 데이터 전송** : 송신자는 윈도우에 포함되는 모든 패킷을 전송함. 이때 확인 응답을 기다리지 않고 윈도우 크기만큼 연속해서 보낼 수 있음.
- **확인 응답(ACK) :** 수신자가 데이터를 받으면 확인 응답을 송신자에게 보냄. ex) Data 0을 받고 ACK2를 보냄.
- **윈도우 이동 :** 송신자는 확인 응답을 받으면 윈도우를 옆으로 옮김. 이때 새로운 데이터를 보낼 수 있는 공간이 생김.
- **재전송** : 만약 특정 패킷에 대한 확인 응답을 받지 못하면 송신자는 그 패킷 이후의 모든 데이터를 다시 전송함. 이 방법을 **Go-Back-N ARQ**라고 함.

**윈도우(window)란?**

- TCP/IP를 사용하는 모든 호스트들은 송신 및 수신용, 2개의 window를 가지고 있음.
- 호스트들은 실제 데이터를 전송하기 전, 3 way handshaking을 통해 수신 호스트의  수신 윈도우 사이즈에 자신의 송신 윈도우 사이즈를 맞춤.
<br/>
<br/>

# 4) 혼잡 제어

송신자가 사용하는 네트워크에 많은 인원이 데이터를 전송하는 상황을 생각해보자. 

라우터가 데이터를 처리하는 속도보다 많은 양의 데이터가 들어오게 되면 문제가 발생한다.

→ 송신자는 라우터가 처리하지 못한 데이터를 잃어버린 것으로 간주하고 다시 데이터를 재전송함. 이는 네트워크의 혼잡(오버플로우 혹은 데이터 손실 등)을 가져오게됨.

*라우터 : 네트워크에서 송신자가 보낸 데이터를 알맞은 수신자에게 보내줌.

**혼잡제어**란, **송신자의 데이터 전송 속도를 조절하여 네트워크의 혼잡 문제를 방지**하는 것.

## 해결 방법

### **AIMD(Additive Increase/Multiplicative Decrease)**

![Untitled120202sdf](https://github.com/Audrey-1120/cs-study/assets/100057254/95f33339-d96c-40e7-a50a-3e3ccac9f60e)

**동작 방식**

- 처음에 패킷을 하나씩 보내면서 시작. 패킷이 문제 없이 도착하면 window 크기를 1씩 늘림.(additive increase)
- 만약 패킷 전송에 실패하거나 일정 시간이 지나도 확인 응답을 받지 못하면 패킷 전송 속도를 절반으로 줄임(multiplicative decrease)

**장점**

- 네트워크를 공유하는 여러 호스트가 공평하게 네트워크 자원을 사용할 수 있으며 시간이 지나면 각 호스트는 균형 상태에 도달함.

**단점**

- 처음에는 네트워크 대역폭을 충분하게 사용하지 못해 전송 속도가 느리며 네트워크가 혼잡해진 후에야 대역폭을 줄이기 때문에 미리 감지하지 못함.  
<br/>
### Slow Start(느린 시작)

네트워크의 수용량 주변에서는 효율적으로 작동하나 처음에 전송 속도를 올리는 데 시간이 오래걸리는 AIMD 방식의 단점을 개선한 방법

**동작 방식**
- 처음에는 패킷을 하나씩 보내면서 시작. 패킷이 문제 없이 도착하면 각 ACK 패킷마다 window 크기를 1씩 늘림.
    - 즉, window 크기가 지수 함수 꼴로 증가(2, 4, 8, 16…)

**장점**

- 전송 속도가 AIMD보다 빠르게 증가해서 네트워크 수용량에 빨리 도달 가능

**단점**

- 혼잡 현상이 발생하면 window 크기를 1로 떨어뜨려야함. 또한 초기에는 네트워크 수용량을 예상할 수 있는 정보가 없음.  
<br/>

### Fast Retransmit(빠른 재전송)

**동작 방식**

- 수신자가 패킷을 순서대로 받지 못하면 중복된 ACK 패킷을 전송함. 송신자는 중복된 ACK 패킷을 3개 받으면 문제가 되는 순번의 패킷 재전송

**장점**

- 패킷 손실을 빠르게 감지하고 재전송할 수 있음. 또한 혼잡 상황을 빠르게 감지하고 window 크기를 줄임.  
<br/>

### Fast Recovery(빠른 회복)

**동작 방식**

- 혼잡 상태가 되면 window 크기를 1로 줄이지 않고 반으로 줄임. 이후에는 window 크기를 선형적으로 증가시킴.(1씩 증가)

**장점**

- 혼잡 상황 이후에도 전송 속도가 급격히 떨어지지 않음. AIMD 방식과 결함되어 효율적으로 동작함.