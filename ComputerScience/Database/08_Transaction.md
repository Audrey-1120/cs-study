# DB 트랜잭션 (Transaction)

### 트랜잭션
> 데이터베이스의 **상태를 변화**시키기 위해 수행하는 **작업 단위**

<br>

상태를 변화시키는 것은 **SQL 질의어를 통해 DB에 접근하는 것**이다.

- SELECT
- INSERT
- DELETE
- UPDATE

<br>

작업 단위는 **많은 SQL 명령문들을 사람이 정하는 기준에 따라 정하는 것**이다.

```
예를 들어 사용자 A가 사용자 B에게 만원을 송금한다.  

이때 DB 작업으로  
1. 사용자 A의 계좌에서 10,000원을 차감한다. -> UPDATE 문을 사용해 사용자 A의 잔고를 변경
2. 사용자 B의 계좌에 10,000원을 추가한다. -> UPDATE 문을 사용해 사용자 B의 잔고를 변경

현재 작업 단위 : 출금 UPDATE 문 + 입금 UPDATE 문
-> 이를 합쳐 하나의 트랜잭션이라고 한다.

 - 위 두 쿼리문 둘 다 완료되어야만 "하나의 작업(트랜잭션)"이 완료되는 것이다. -> Commit
 - 작업 단위에 속하는 쿼리 중 하나라도 실패하면 모든 쿼리문을 취소하고 이전 상태로 돌려놓아야한다. -> Rollback
 ```

즉, **하나의 트랜잭션 설계를 잘 만드는 것**이 **데이터를 다룰 때 많은 이점을 가져다 준다.**

<br>

### 트랜잭션 특징

- 원자성(Atomicity)
    > 트랜잭션이 DB에 모두 반영되거나, 혹은 전혀 반영되지 않아야 한다.

- 일관성(Consistency)
    > 트랜잭션의 작업 처리 결과는 항상 일관성 있어야 한다.

- 독립성(Isolation)
    > 둘 이상의 트랜잭션이 동시에 병행 실행되고 있을 때, 어떤 트랜잭션도 다른 트랜잭션 연산에 끼어들 수 없다.

- 지속성(Durability)
    > 트랜잭션이 성공적으로 완료되었으면, 결과는 영구적으로 반영되어야 한다.

<br>

### Commit
하나의 트랜잭션이 성공적으로 끝났고, DB가 일관성있는 상태일 때 이를 알려주기 위해 사용하는 연산

### Rollback
하나의 트랜잭션 처리가 비정상적으로 종료되어 트랜잭션 원자성이 깨진 경우  
트랜잭션이 정상적으로 종료되지 않았을 때, last consistent state(트랜잭션 시작 상태)로 rollback 할 수 있음

<br>

### 트랜잭션 관리를 위한 DBMS의 전략

#### 1. DBMS의 구조

- Query Processor(질의 처리기), Storage System(저장 시스템)으로 구성된다.


<br>

#### 2. Page Buffer Manager or Buffer Manager

DBMS의 Storage System에 속하는 모듈 중 하나  
Main Memory에 유지하는 페이지를 관리하는 모듈

> Buffer 관리 정책에 따라, UNDO 복구와 REDO 복구가 요구되거나 그렇지 않게 되므로, 트랜잭션 관리에 매우 중요한 결정을 가져온다.

<br>

#### 3. UNDO

- 필요한 이유  
수정된 Page들이 <u>**Buffer 교체 알고리즘에 따라서 디스크에 출력**</u>될 수 있다.  
Buffer 교체는 트랜잭션과는 무관하게 **Buffer의 상태에 따라서** 결정된다.  
아직 완료되지 않은 트랜잭션이 수정한 페이지들도 디스크에 출력될 수 있으므로  
<u>정상적으로 종료되지 않은 트랜잭션이 변경한 page들은 원상 복구되어야 하는데</u>, 이 복구를 **UNDO**라고 한다.  

- <u>수정된 페이지를 디스크에 쓰는 시점</u>을 기준으로 2가지 정책으로 나눌 수 있다.

    - STEAL  
    수정된 페이지를 언제든지 디스크에 쓸 수 있는 정책
        - 대부분의 DBMS가 채택하는 buffer 관리 정책
        - 수정된 페이지가 어떠한 시점에도 디스크가 사용될 수 있기 때문에 UNDO logging과 복구를 필요로 함

    - ¬STEAL(NO STEAL)  
    수정된 페이지들을 EOT(End Of Transaction)까지는 버퍼에 유지하는 정책
        - 만약 버퍼 관리자가 트랜잭션 종료 전에는 어떤 경우에도 수정된 페이지들을 디스크에 쓰지 않는다면, UNDO 오퍼레이션은 메모리 버퍼에 대해서만 이루어지면 되는 식으로 매우 간단해질 수 있다.  
        - 이 정책은 매우 큰 크기의 메모리 버퍼가 필요하다는 문제점을 가지고 있다.

<br>

#### 4. REDO

- UNDO 복구의 반대 개념
- 이미 commit한 트랜잭션의 수정을 재반영하는 복구 작업
- buffer 관리 정책에 영향을 받는다.

<br>

- 트랜잭션이 종료되는 시점에 해당 트랜잭션이 수정한 페이지를 디스크에 쓸 것인가 아닌가로 기준

    - FORCE  
    수정했던 모든 페이지를 트랜잭션 commit 시점에 디스크에 반영하는 정책
        - FORCE를 따르면 트랜잭션이 commit 되었을 때 수정된 페이지들이 디스크 상의 DB에 반영되므로 REDO가 필요 없다.

    - ¬FORCE(NO FORCE)
    수정했던 페이지를 트랜잭션 commit 시점에 디스크에 반영하지 않는 정책
        - 트랜잭션이 디스크 상의 DB에 반영되지 않을 수 있기에 REDO 복구가 필요하다.
        - 대부분의 DBMS 정책으로 채택 (FORCE 정책을 따르더라도 DB 백업으로부터의 복구인 미디어 복구 시에는 REDO 복구가 요구됨)

<br>

#### 문제
Rollback은 하나의 트랜잭션 처리가 비정상적으로 종료되어 트랜잭션 □□□이 깨진 경우
    
    1) 일관성   2) 원자성   3) 지속성

<br>

##### [참고]
[DBMS는 어떻게 트랜잭션을 관리할까?](<https://d2.naver.com/helloworld/407507>)
[REDO와 UNDO 동작 과정을 이해해보자](<https://loosie.tistory.com/527>)
