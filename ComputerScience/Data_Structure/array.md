# 배열

> 배열 회전
> 

→  배열이 오른쪽으로 돌면 오른쪽 회전, 왼쪽으로 돌면 왼쪽 회전이다.

    1회전은 1칸씩 이동한 것이고 2회전은 2칸씩 이동한 것이다.

    즉, 왼쪽 2회전 메소드라고 한다면 배열의 값을 왼쪽으로 두 칸씩 옮기는 메소드

## 배열 회전 알고리즘

- 기본 알고리즘

```java
void leftRotatebyOne(int arr[], int n){
    int temp = arr[0], i;
    for(i = 0; i < n-1; i++){
       arr[i] = arr[i+1];
    }
    arr[i] = temp;
}
```

어떤 배열의 n+1번 위치의 값을 n번 위치로 바꾸는 알고리즘(왼쪽 1회전)이다.

더이상 왼쪽으로 갈 곳이 없는 배열의 첫번째 값은 temp에 미리 넣어놨다가 모든 값을 옮긴 후 배열의 가장 마지막 위치에 넣어준다.

이걸 두 번 반복할 경우 2회전, 3번 반복할 경우 3회전, …n번 반복할 경우 n회전 왼쪽 회전이 됨.

(오른쪽 회전일 경우 더이상 오른쪽으로 갈 곳이 없는 배열의 마지막 값을  temp에 넣어놨다가 arr[i+1]=arr[i] 식으로 전개되는 for문이 끝난후 비어있는 배열의 첫번째 값으로 가게 될 것이다. )

- 저글링 알고리즘

최대공약수를 이용해 배열을 집합으로 나누어 집합을 한 번에 이동시키는 것이다.

절에 가면 팔이 여러개이신 분들이 있다.

나도 잠깐 그렇게 되었다고 생각해보자. 내가 팔이 12개다. 그리고 팔마다 사과를 하나씩 쥐고 있다.

이 사과들을 모두 왼쪽으로 3번째 팔에 전달해주고 싶다.

12와 3의 최대공약수는 3이다.  (+ 주로 유클리드 호제법으로 최대공약수를 찾는다)

3번의 집합간 이동을 통해 회전시킬 것이다.

1 2 3 / 4 5 6 / 7 8 9 / 10 11 12 ( 내 팔이라고 생각해본다.)

왼쪽에 있는 사과를 던질때 받아줄 왼팔이 더 없으니 가운데에서 그걸 슥 받아 오른쪽으로 가져다줄 임시 팔이 있다고 생각해보자. (int temp;)

첫번째 이동 (각 집합의 첫번째가 왼쪽 집합의 첫번째로 이동)

1번은 temp에, 4번팔은 1번팔에, 7번은 4번팔에 10번은 7번 팔에, temp은 10번 팔에 사과를 던진다.

4 2 3 / 7 5 6 / 10 8 9 / 1 11 12 가 되었다.

두번째 이동(각 집합의 두번째가 왼쪽 집합의 두번째로 이동)

2번은 temp에, 5번팔은 2번팔에, 8번팔은 5번팔에, 11번팔은 8번 팔에,  temp은 11번 팔에 던진다.

4 5 3 / 7 8 6 / 10 11 9 / 1 2 12

세번째 이동(각 집합의 세번째가 왼쪽 집합의 세번째로 이동)

3번은 temp에, 6번 팔은 3번팔에, 9번 팔은 6번팔에, 12번 팔은 9번 팔에, temp은 12번 팔에 던진다.

4 5 6 / 7 8 9 / 10 11 12 / 1 2 3

이제 내 손에 있는 사과들이 왼쪽으로 3칸씩 이동했다.

왼쪽으로 3회전한 배열이 되었다!

각각의 서브셋이 가진 값의 개수만큼 for문이 돌 것이라는 것을 알 수 있다.

이러한 회전 알고리즘을 저글링 알고리즘이라고 한다.

(저글링 알고리즘의 구현 코드는 아래와 같다)

```java
void leftRotate(int arr[], int d, int n) 
{ 
    for (int i = 0; i < gcd(d, n); i++) { 
       
        int temp = arr[i]; 
        int j = i; 
  
        while (1) { 
            int k = j + d; 
            if (k >= n) 
                k = k - n; 
  
            if (k == i) 
                break; 
  
            arr[j] = arr[k]; 
            j = k; 
        } 
        arr[j] = temp; 
    } 
} 
```

(+최대공약수를 이용한 알고리즘이라서 소수가 끼기 시작하면 효율이 적어진다. 최대공약수가 1이라면 가장 기본적인 첫번째 알고리즘과 똑같은 모양새로 흘러가게 될 것이다.)

- 역전 알고리즘

몇회전을 할 것인지에 따라 구역을 나누어 구역을 역전시킨뒤 다시 합쳐서 역전시켜 만드는 알고리즘이다. 정리하자면 아래와 같다.

배열을 `d`칸 왼쪽으로 회전하기 위한 역전 알고리즘

1. 배열의 첫 번째 부분 (0부터 d-1까지)을 뒤집음
2. 배열의 두 번째 부분 (d부터 n-1까지)을 뒤집음
3. 전체 배열을 뒤집음

→ 배열이 `d`칸 왼쪽으로 회전함

역전 알고리즘으로 1, 2, 3, 4, 5 가 있다고 할때 왼쪽으로 2칸 회전한 배열을 만들어보자.

1, 2 / 3, 4, 5  → 2칸을 기준으로 나눔.

2, 1 / 5, 4, 3 → 각 구역을 역전시킴

2, 1, 5, 4, 3 → 합침

3, 4, 5, 1, 2 → 합친 배열을 뒤집음

→ 역전 알고리즘이 기본 알고리즘보다 효율적인 이유: 역전을 이용하기 때문이다. 역전의 이동횟수는 n/2이기 때문에! (서로서로 자리를 바꾸니까 칸별로 이동하는 것보다 효율적이다.) 

역전 알고리즘의 핵심은 이름대로 역전!

(역전 알고리즘의 구현 코드는 아래와 같다.)

```java
void reverseArr(int arr[], int start, int end){
    
    while (start < end){
        int temp = arr[start];
        arr[start] = arr[end];
        arr[end] = temp;
        
        start++;
        end--;
    }
}

// d로 나눠서 역전 알고리즘 수행
void rotateLeft(int arr[], int d, int n){
    reverseArr(arr, 0, d-1);
    reverseArr(arr, d, n-1);
    reverseArr(arr, 0, n-1);
}
```

## 배열 회전의 최대값 구하기

ex) arr[i]가 있을 때, i*arr[i] 의 SUM이 최대값이 되는 조합 구하기

도출되는 식 `Rj - Rj-1 = arrSum - n * arr[n-j]` 를 통해서 구할 수 있다.

```java
int maxVal(int arr[], int n){
    
    int arrSum = 0; // arr[i]의 전체 합
    int curSum = 0; // i*arr[i]의 전체 합
    
    for(int i = 0; i < n; i++){
        arrSum = arrSum + arr[i];
        curSum = curSum + (i*arr[i]);
    }
    
    int maxSum = curSum;
    
    for (int j = 1; j < n; j++){
        curSum = curSum + arrSum - n*arr[n-j];
        
        if ( curSum > maxSum )
            maxSum = curSum;
    }
    
    return maxSum;
    
}
```

## 배열의 재배치

ex) 주어진 배열에서 arr[i] = i이 가능한 것만 재배열

```java
int fix(int A[], int len){
    
    for(int i = 0; i < len; i++) {
        
        
        if (A[i] != -1 && A[i] != i){ // A[i]가 -1이 아니고, i도 아닐 때
            
            int x = A[i]; // 해당 값을 x에 저장
            
            while(A[x] != -1 && A[x] != x){ // A[x]가 -1이 아니고, x도 아닐 때
                
                int y = A[x]; // 해당 값을 y에 저장
                A[x] = x; 
                
                x = y;
            }
            
            A[x] = x;
            
            if (A[i] != i){
                A[i] = -1;
            }
        }
    }
    
}

```

 

출처 | https://gyoogle.dev/