# 자바의 컴파일 과정

## 들어가기 전에..

![Untitled_2407179829843](https://github.com/user-attachments/assets/fe3fa8ac-9e81-455e-9533-7a91c0403f37)

**JVM(Java Virtual Machine) 이란?**

- 자바 가상 머신. 자바 프로그램 실행환경을 만들어주는 소프트웨어이다. 자바 코드를 컴파일하여 .class 바이트코드로 만들어주면 이 코드가 자바 가상 머신 환경에서 실행된다. JVM은 자바 실행 환경 JRE에 포함되어 있다.
- 자바는 OS에 독립적인 특징이 있는데, 이러한 특징을 가능하게 해주는 것이 바로 JVM.

**JRE(Java Runtime Ecvironment)이란?**

- JVM으로 보내주는 바이트 코드를 생성한다. 자바 실행 명령, 클래스 로더와 바이트 코드의 실행에 필요한 라이브러리를 제공한다.
- 개발에 관련된 도구는 포함하지 않는다.

**JDK(Java Development Kit)란?**

- 컴파일러, 역 어셈블러, 디버거, 의존관계 분석 등 개발에 필요한 도구를 제공한다. JVM, JRE 그리고 개발환경에 도와주는 툴, 소스코드를 개발하는데 사용하는 자바 언어는 플랫폼에 독립적이다.

**클래스 로더(Class Loader)란?**

- 자바는 실행중에 필요한 클래스 파일들을 동적으로 메모리에 불러온다. 이 일을 하는 것이 바로 클래스 로더이다.
- 다시말해 클래스를 동적으로 로딩해주기 때문에 프로그램 실행중에 필요한 코드를 자바 가상 머신(JVM)과 연결해주는 역할을 한다.
- 자바에서 소스코드를 작성하면 .java 파일이 생성되고 .java 소스를 컴파일러가 컴파일하면 .class 파일이 생성된다. 클래스 로더는 .class 파일을 묶어서 JVM이 운영체제로부터 할당받은 메모리 영역인 Runtime Data Area로 적재한다.

**런타임 데이터 영역(Runtime Data Area)란?**

- 런타임 데이터 영역은 JVM의 메모리 영역으로, 자바 애플리케이션을 실행할 때 사용되는 데이터들을 적재하는 영역이다.
![image](https://github.com/user-attachments/assets/d1be4471-5844-4b03-96d4-6a4ece57d9c6)
- 메소드(정적) 영역: 클래스 정보, 메소드 코드, 상수 등이 저장되는 영역이다.
    - 프로그램 실행 시 클래스가 로드되면 이 영역에 클래스 정보가 저장된다.
- 런타임 상수 풀: 클래스 상수 및 리터럴이 저장되는 영역이다.
    - 프로그램에서 사용되는 상수 값들이 이 영역에 저장된다.
- 힙 영역: 객체 인스턴스와 배열이 저장되는 영역이다.
    - 프로그램에서 생성되는 객체들이 이 영역에 저장된다.
- 스택 영역: 메서드 호출 시 생성되는 스레드 별 스택 프레임이 저장되는 영역이다.
    - 메소드가 호출되면 해당 메소드의 지역 변수와 매개변수가 스택 프레임에 저장된다.
- PC 레지스터: 현재 실행 중인 JVM 명령의 주소를 저장하는 레지스터이다.
    - 스레드 별로 PC 레지스터가 관리된다.
- 네이티브 메서드 스택: 네이티브 메서드 호출 시 사용되는 스택 영역이다.

## Java의 컴파일 과정

![img_java_programming234234](https://github.com/user-attachments/assets/27cadf5c-4fa4-472c-918d-65d56e386bb2)

1. 개발자가 자바 소스코드(.java)를 작성한다.
2. 자바 컴파일러가 자바 소스코드(.java)파일을 읽어 바이트코드(.class)코드로 컴파일한다.
    - **바이트코드(.class)란?**
        - **자바 가상 머신(JVM)이 이해할 수 있는 언어로 변환된 자바 소스 코드**이다.
        - 자바 컴파일러로 변환되는 코드 명령어 크기가 1바이트라서 바이트 코드라고 불린다.
3. 컴파일된 바이트 코드(.class)를 JVM의 클래스로더(Class Loader)에게 전달한다.
4. 클래스 로더는 동적로딩을 통해 필요한 클래스들을 로딩 및 링크하여 런타임 데이터 영역(Runtime Data Area의 Method Area), 즉 JVM의 메모리에 올린다.  
<br>
    

>    ### 클래스 로더 세부 동작
> 
>    1) 로드 : 클래스 파일(.class)을 가져와서 JVM의 메모리에 로드한다. 
>        - ex) 도서관에서 책을 꺼내온다.
>    2) 검증 : 자바 언어 명세 및 JVM 명세에 명시된 대로 구성되어 있는지 검사한다. 
>        - ex) 책의 내용이 올바른지 검토한다.
>    3) 준비 : 클래스가 필요로 하는 메모리를 할당한다. (필드, 메소드, 인터페이스 등)
>        - ex) 책에 필요한 페이지를 다 만들어 놓는다.
>    4) 분석 : 클래스의 내부의 모든 심볼릭 레퍼런스를 실제 레퍼런스로 바꾼다.
>        - ex) 책 속에서의 ‘이 책의 10페이지 참조’ 부분을 ‘정확한 10페이지 내용’으로 변경한다.
>    5) 초기화 : 클래스 변수(statis 변수)들을 적절한 값으로 초기화한다. (static 필드)
>        - ex) 책의 시작 부분에 미리 정해진 내용을 써놓는 것.

<br>    

1. 실행엔진(Execution Engine)은 JVM 메모리에 올라온 바이트 코드들을 명령어 단위로 하나씩 가져와서 실행함. 이때 실행 엔진은 두가지 방식으로 변경한다.
    
    **먼저, 컴파일이란?**
    
    - 전체 소스 코드를 한 번에 기계어로 변환하는 것을 뜻함.
    
    **인터프리터**
    
    바이트 코드 명령어를 하나씩 읽어서 해석하고 실행한다.
    
    - 다시 말해서, 실행 중 프로그래밍 언어를 한줄 씩 읽어가면서 해당 기능에 대응하는 기계어 코드를 실행한다.
    - 하나하나의 실행은 빠르나, 전체적인 실행 속도가 느리다.
    - ex) JavaScript, Ruby, Python
    
     
    
    **JIT 컴파일러**
    
    인터프리터의 단점을 보완하기 위해 도입된 방식, 인터프리터 + 정적 컴파일러라고 보면 된다.
    
    - 실행 시점에서 인터프리터 방식으로 기계어 코드를 생성함과 동시에 그 코드를 캐싱한다.
    
    ---
    
    예시) 예를 들어, 다음과 같은 Java 프로그램이 있다.
    
    ```java
    public class Example {
        public static void main(String[] args) {
            int x = 10;
            int y = 20;
            int z = add(x, y);
            System.out.println(z);
        }
    
        public static int add(int a, int b) {
            return a + b;
        }
    }
    
    ```
    
    1. JVM이 이 Java 프로그램을 실행할 때 JIT 컴파일러는 처음에 인터프리터 방식으로 코드를 실행한다.
    2. 실행 중 add() 메소드가 자주 호출되는 것을 감지하면, JIT 컴파일러는 해당 메소드만 선별적으로 기계어 코드로 컴파일 한다.
    3. 컴파일된 add() 메소드는 캐싱되어 다음에 호출할 때 바로 사용할 수 있다.
    4. 즉, 프로그램 실행 시 JIT 컴파일러는 필요한 부분만 선별적으로 컴파일 하여 실행한다.
    
    ---
    
    - 전체적인 실행속도가 인터프리팅 방식보다 빠르다. (하나씩 인터프리팅하여 실행하는 것이 아니라 바이트 코드 전체가 컴파일된 바이너리 코드를 실행하는 것이기 때문)
    - 캐시처리를 통해 같은 함수가 여러 번 불릴 때 미번 기계어 코드를 생성하는 것을 방지할 수 있다. 다시말해 효율적이다.
    
    JVM은 인터프리터 방식과 JIT 컴파일러 방식을 혼합하여 사용한다. 초기에는 인터프리터 방식으로 실행하다가, 자주 실행되는 메소드를 JIT 컴파일러가 감지하여 기계어로 컴파일한다. 이를 통해 실행속도와 메모리 사용량의 균형을 맞추어 효율적으로 자바 프로그램을 실행할 수 있다.
    

(참고용)

** 그러면 정적 컴파일러와 JIT 컴파일러의 차이는?

1. 컴파일 시점의 차이
    - 정적 컴파일러: 프로그램 작성 시점에 전체 코드를 한 번에 컴파일한다.
    - JIT 컴파일러: 프로그램 실행 시점에 필요한 부분만 선택적으로 컴파일한다.
2. 최적화 기회
    - 정적 컴파일러: 프로그램 전체에 대한 정보를 바탕으로 최적화를 수행할 수 있다.
    - JIT 컴파일러: 실행 시점의 정보를 활용하여 동적으로 최적화를 수행할 수 있다.
3. 실행 속도
    - 정적 컴파일러: 전체 코드를 미리 컴파일하므로 실행 속도가 빠르다.
    - JIT 컴파일러: 실행 시점에 컴파일하므로 초기 실행 속도가 느릴 수 있지만, 자주 실행되는 부분은 최적화되어 빨라진다.
4. 메모리 사용량
    - 정적 컴파일러: 전체 코드를 미리 컴파일하므로 메모리 사용량이 더 많다.
    - JIT 컴파일러: 필요한 부분만 선택적으로 컴파일하므로 메모리 사용량이 상대적으로 적다.


---
문제) 빈칸에 알맞은 말을 넣으세요.  
> 자바 컴파일 과정에서 자바컴파일러는 개발자가 작성한 소스코드 파일을 읽어 (&ensp;1&ensp;)로 컴파일 한다. 여기서 (&ensp;1&ensp;)은 자바 가상 머신이 이해할 수 있는 언어로 변환된 자바 소스코드를 뜻한다.

> 컴파일 된 (&ensp;1&ensp;)를 JVM의 클래스 로더가 받아서 JVM의 메모리 영역인 (&ensp;2&ensp;)에 적재한다.

> JVM은 Java 프로그램을 실행할 때 처음에는(&ensp;3&ensp;)방식으로 코드를 실행하다가 자주 실행되는 메소드를 (&ensp;3&ensp;)가 감지하여 기계어로 컴파일한다.

---

**참고자료**

[1주차 : Byte Code 란 무엇인가 ?](https://wooktae.tistory.com/23)

[[Java] 자바 컴파일 과정 & JVM 내부 구조](https://velog.io/@minseojo/Java-자바-컴파일-과정-JVM-내부-구조)

[[Java-3] JVM과 JIT 컴파일러란?](https://catch-me-java.tistory.com/11)