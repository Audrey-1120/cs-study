# 자바의 컴파일 과정

## 들어가기 전에..

**JVM(Java Virtual Machine) 이란?**

- 자바 가상 머신. 자바 프로그램 실행환경을 만들어주는 소프트웨어이다. 자바 코드를 컴파일하여 .class 바이트코드로 만들어주면 이 코드가 자바 가상 머신 환경에서 실행된다. JVM은 자바 실행 환경 JRE에 포함되어 있다.
- 자바는 OS에 독립적인 특징이 있는데, 이러한 특징을 가능하게 해주는 것이 바로 JVM.

**클래스 로더(Class Loader)란?**

- 자바는 실행중에 필요한 클래스 파일들을 동적으로 메모리에 불러온다. 이 일을 하는 것이 바로 클래스 로더이다.
- 다시말해 클래스를 동적으로 로딩해주기 때문에 프로그램 실행중에 필요한 코드를 자바 가상 머신(JVM)과 연결해주는 역할을 한다.
- 자바에서 소스코드를 작성하면 .java 파일이 생성되고 .java 소스를 컴파일러가 컴파일하면 .class 파일이 생성된다. 클래스 로더는 .class 파일을 묶어서 JVM이 운영체제로부터 할당받은 메모리 영역인 Runtime Data Area로 적재한다.

**런타임 데이터 영역(Runtime Data Area)란?**

- 런타임 데이터 영역은 JVM의 메모리 영역으로, 자바 애플리케이션을 실행할 때 사용되는 데이터들을 적재하는 영역이다.
    

## Java의 컴파일 과정

![img_java_programming234234](https://github.com/user-attachments/assets/27cadf5c-4fa4-472c-918d-65d56e386bb2)

1. 개발자가 자바 소스코드(.java)를 작성한다.
2. 자바 컴파일러가 자바 소스코드(.java)파일을 읽어 바이트코드(.class)코드로 컴파일한다.
    - **바이트코드(.class)란?**
        - **자바 가상 머신(JVM)이 이해할 수 있는 언어로 변환된 자바 소스 코드**이다.
        - 자바 컴파일러로 변환되는 코드 명령어 크기가 1바이트라서 바이트 코드라고 불린다.
3. 컴파일된 바이트 코드(.class)를 JVM의 클래스로더(Class Loader)에게 전달한다.
4. 클래스 로더는 동적로딩을 통해 필요한 클래스들을 로딩 및 링크하여 런타임 데이터 영역(Runtime Data Area의 Method Area), 즉 JVM의 메모리에 올린다.  
<br>
    

>    ### 클래스 로더 세부 동작
> 
>    1) 로드 : 클래스 파일(.class)을 가져와서 JVM의 메모리에 로드한다. 
>        - ex) 도서관에서 책을 꺼내온다.
>    2) 검증 : 자바 언어 명세 및 JVM 명세에 명시된 대로 구성되어 있는지 검사한다. 
>        - ex) 책의 내용이 올바른지 검토한다.
>    3) 준비 : 클래스가 필요로 하는 메모리를 할당한다. (필드, 메소드, 인터페이스 등)
>        - ex) 책에 필요한 페이지를 다 만들어 놓는다.
>    4) 분석 : 클래스의 내부의 모든 심볼릭 레퍼런스를 실제 레퍼런스로 바꾼다.
>        - ex) 책 속에서의 ‘이 책의 10페이지 참조’ 부분을 ‘정확한 10페이지 내용’으로 변경한다.
>    5) 초기화 : 클래스 변수(statis 변수)들을 적절한 값으로 초기화한다. (static 필드)
>        - ex) 책의 시작 부분에 미리 정해진 내용을 써놓는 것.

<br>    

5. 실행엔진(Execution Engine)은 JVM 메모리에 올라온 바이트 코드들을 명령어 단위로 하나씩 가져와서 실행함. 이때 실행 엔진은 두가지 방식으로 변경한다.
>    - **인터프리터** : 바이트 코드 명령어를 하나씩 읽어서 해석하고 실행한다.
>        - 하나하나의 실행은 빠르나, 전체적인 실행 속도가 느리다.
>        - ex) JavaScript, Ruby, Python
>    - **JIT 컴파일러(Just-In-Time Compiler)** : 인터프리터의 단점을 보완하기 위해 도입된 방식으로 바이트 코드 전체를 컴파일하여 바이너리 코드(기계어)로 변경하고 이후에는 해당 메소드를 더이상 인터프리팅(해석) 하지 않고, 바이너리 코드로 직접 실행한다.
>        - 전체적인 실행속도가 인터프리팅 방식보다 빠르다. (하나씩 인터프리팅하여 실행하는 것이 아니라 바이트 코드 전체가 컴파일된 바이너리 코드를 실행하는 것이기 때문)
>        - 요리사가 처음에 레시피를 다 외우고, 그 다음부터 빠르게 요리하는 것과 같음. 처음 준비 시간이 좀 걸리지만 전체적으로 더 빨리 요리를 완성할 수 있음.
>        - 정적 컴파일 방식과 인터프리터 방식을 혼합한 방식이라고 생각하면 된다. 실행 시점에서 인터프리터 방식으로 기계어 코드를 생성함과 동시에 그 코드를 캐싱한다.
>            - 캐시처리를 통해 같은 함수가 여러 번 불릴 때 미번 기계어 코드를 생성하는 것을 방지함.
>    - 정리하자면 자바 컴파일러가 자바 소스 코드를 바이트 코드로 변환하여 최적화한다. 그런 다음, 바이트 코드가 실행되는 과정에서 실시간으로 JIT 컴파일러가 바이트 코드를 기계어로 변환한다. 실행되는, 즉 필요한 부분만 변환된다. 변환된 기계어 코드는 캐싱되어 다시 컴파일할 필요가 없다.

 

---

**참고자료**

[1주차 : Byte Code 란 무엇인가 ?](https://wooktae.tistory.com/23)

[[Java] 자바 컴파일 과정 & JVM 내부 구조](https://velog.io/@minseojo/Java-자바-컴파일-과정-JVM-내부-구조)