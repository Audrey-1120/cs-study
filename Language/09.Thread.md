# 스레드


## 들어가기전에..

**프로세스란?**

- 일반적으로 cpu에 의해 메모리에 올려져 실행중인 프로그램을 말한다.
- JVM은 주로 하나의 프로세스로 실행되며, 동시에 여러 작업을 수행하기 위해서 멀티 스레드를 지원하고 있다.

**멀티스레드란?**

- 둘 이상의 스레드를 동시에 실행하는 것.

**프로세스와 스레드의 차이점**

- 프로세스는 운영체제로부터 자원을 할당받는 작업 단위이다.
- 애플리케이션이 하나의 프로세스가 되고, 그 안에서 여러 개의 스레드가 할당 받은 자원을 이용하여 실행 단위로 존재할 수 있다.
    - 즉 스레드는 하나의 프로세스 안에서 여러 실행의 흐름이라고 생각하면 된다.

최근 나오는 운영체제는 모두 멀티태스킹을 지원한다.

여기서 멀티 태스킹이란? 두가지 이상의 작업을 동시에 하는 것을 뜻한다.

실제로 동시에 처리될 수 있는 프로세스의 개수는 CPU 코어의 개수와 동일한데, 이보다 많은 개수의 프로세스가 존재하기 때문에 모두 함께 동시에 처리할 수는 없다.

각 코어들은 아주 짧은 시간동안 여러 프로세스를 번갈아가며 처리하는 방식을 통해 동시에 동작하는 것처럼 보이게 할 뿐이다.

이와 마찬가지로, 멀티스레딩이란 하나의 프로세스 안에 여러 개의 스레드가 동시에 작업을 수행하는 것을 말한다. 

- 여기서 스레드는 하나의 작업 단위라고 보면 된다.

## 스레드 구현

자바에서 스레드 구현 방법은 2가지가 있다.

- 둘다 run() 메소드를 오버라이딩 하는 방식이다.

1. **Runnable 인터페이스 구현**
    - Runnable 인터페이스를 구현하면, run() 메소드를 오버라이드하여 스레드에서 실행할 코드를 정의한다.
    - Runnable을 구현하는 방식은 스레드가 할 작업을 정의하는 것과 스레드 자체를 생성하는 것을 분리할 수 있어, 코드의 재사용성이 높다.
    - 예를 들어 여러 스레드가 동일한 작업을 수행할 때 유용하다.

1. **Thread 클래스 상속**
    - Thread 클래스를 상속하면, run() 메소드를 오버라이드하여 스레드에서 실행할 코드를 정의한다.
    - 이 방법은 스레드의 속성을 직접적으로 다룰 수 있지만, 단일 상속만 가능하므로 다른 클래스를 상속받을 수 없는 단점이 있다.

## 스레드 생성

- 두가지 방법은 인스턴스 생성 방법에 차이가 있다.
1. **Runnable 인터페이스 구현**

```java
public class MyRunnable implements Runnable {
    @Override
    public void run() {
        // 스레드에서 실행할 코드
        System.out.println("스레드 실행 중");
    }
}

public static void main(String[] args) {
    Runnable r = new MyRunnable(); // Runnable 인스턴스 생성
    Thread t = new Thread(r, "mythread"); // Thread 생성자에 Runnable 인스턴스를 넘김
    t.start(); // 스레드 시작
}
```

- Runnable 클래스 생성
    - Runnable 인터페이스를 구현한 클래스를 작성한다.
    - 이 클래스에서 run() 메소드를 오버라이드하여 스레드가 실행할 코드를 작성한다.
- 스레드 생성
    - 이 클래스의 인스턴스를 생성하고, Thread 클래스의 생성자에 인자로 넘겨 새로운 스레드를 생성한다.
- 스레드 시작
    - start() 메소드를 호출하여 스레드를 시작한다.

**장점**

- Runnable을 구현하는 클래스는 다른 클래스를 상속받을 수 있어, 유연성이 높다.
- run() 메서드를 직접 호출할 필요가 없으며, Thread 객체가 이를 자동으로 호출한다.

1. **Thread 클래스 상속**

```java
public class MyThread extends Thread {
    @Override
    public void run() {
        // 스레드에서 실행할 코드
        System.out.println("스레드 실행 중");
    }
}

public static void main(String[] args) {
    MyThread thread = new MyThread(); // Thread 클래스 인스턴스 생성
    thread.start(); // 스레드 시작
}
```

- Thread 클래스 생성
    - Thread 클래스를 상속받은 새로운 클래스를 작성한다.
    - 이 클래스에서 run() 메서드를 오버라이드하여 스레드가 실행할 코드를 작성한다
- 스레드 생성 및 시작
    - 해당 클래스의 인스턴스를 생성하고, start() 메서드를 호출하여 스레드를 시작한다.

**장점**

- Thread 클래스를 상속하면 스레드의 메서드(예: getName())를 직접 사용할 수 있다.
- 별도의 Runnable 객체를 생성할 필요가 없다.

## 스레드 실행

왜 스레드의 실행은 run() 호출이 아니라 start() 호출일까?

**run()과 start()의 차이**

- run() 메소드
    - run() 메소드는 스레드가 실행할 작업을 정의한다. 그러나 이 메소드를 직접 호출하면 그 작업이 현재 스레드(즉, main 스레드)에서 실행된다.
    - 예를 들어 Thread객체에서 run()을 호출하면, 새로운 스레드가 아니라 현재 스레드가 run()의 코드를 실행하게 된다.
- start()메소드
    - start() 메소드에서는 새로운 스레드를 시작한다. 해당 메소드를 호출하면 JVM이 새로운 콜 스택을 생성하고 그 안에서 run() 메소드를 실행한다.
    - 즉, start()를 사용하면 실제로 새로운 스레드가 생성되고, 그 스레드가 독립적으로 run() 메소드를 실행하게 된다.

**콜 스택(call stack)의 역할** 

- 콜 스택(call stack)이란?
    - 콜 스택은 메소드 호출의 정보를 저장하는 메모리 영역이다. 현재 실행 중인 메소드와 그에 대한 정보를 관리한다.
    - 스레드가 여러 개 일경우, 각 스레드는 독립적인 콜스택을 가지게 된다. 이로 인해 동시에 여러 작업을 처리할 수 있게 된다.

예시 1) run()으로 호출한 경우

```java
public class MyThread extends Thread {
    @Override
    public void run() {
        System.out.println("스레드 실행 중");
    }
}

public static void main(String[] args) {
    MyThread thread = new MyThread();
    thread.run(); // 여기서 run()을 직접 호출
    // 결과: "스레드 실행 중"이 main 스레드에서 실행됨
}
```

- 이 경우 run() 메소드는 main 스레드에서 실행되므로, 새로운 스레드를 사용하지 않는다.
- 따라서 멀티스레딩의 이점을 활용하지 못한다.

예시 2) start()로 호출한 경우

```java
public class MyThread extends Thread {
    @Override
    public void run() {
        System.out.println("스레드 실행 중");
    }
}

public static void main(String[] args) {
    MyThread thread = new MyThread();
    thread.start(); // start()를 호출
    // 결과: "스레드 실행 중"이 새로운 스레드에서 실행됨
}
```

- 이 경우 start() 메소드를 호출하면 JVM이 새로운 콜 스택을 생성하고, 그 안에서 run() 메소드를 실행한다.
- 이로 인해 main 스레드와 별개로 동작한다.

## 스레드의 실행제어

스레드의 상태는 5가지가 있다.

`NEW` : 스레드가 생성되고 아직 start()가 호출되지 않은 상태

`RUNNABLE` : 실행 중 또는 실행 가능 상태

`BLOCKED` : 동기화 블럭에 의해 일시정지된 상태(lock이 풀릴 때까지 기다림)

`WAITING, TIME_WAITING` : 실행가능하지 않은 일시정지 상태

`TERMINATED` : 스레드 작업이 종료된 상태

- 스케줄링과 관련된 메소드는 sleep(), join(), yield(), interrupt()와 같은 것들이 있다.

## 동기화

**동기화란?**

멀티스레드 프로그래밍에서 여러 스레드가 같은 자원(변수, 데이터 구조 등)을 동시에 접근하고 수정할 때, 서로의 작업이 영향을 주지 않도록 하는 것이다.

예를 들어, 두 개의 스레드가 같은 변수를 동시에 수정하면, 예상치 못한 결과가 발생할 수 있다.

- 이를 방지하기 위해 동기화가 필요하다.

## 임계 영역과 잠금

**임계 영역**

- 임계 영역은 공유 자원에 접근하는 코드 블록을 의미한다.
- 이곳에서는 오직하나의 스레드만 접근할 수 있어야 한다.

**잠금(lock)**

- 임계 영역에 접근하기 위해 사용하는 매커니즘이다. 잠금을 가진 스레드만 임계 영역에 들어갈 수 있으며, 작업이 끝나면 잠금을 반납해야 한다.
- 이를 통해 다른 스레드가 같은 자원에 동시에 접근하지 못하도록 한다.

## 동기화 방법

1. **임계 영역 (Critical Section)**
    - 특정 자원에 단 하나의 스레드만접근하도록 제한한다.
    - 즉, 같은 프로세스 내에서 스레드 간의 상호 배제를 보장한다.
2. **뮤텍스** 
    - 뮤텍스는 임계 영역과 유사하지만, 서로 다른 프로세스에 속한 스레드도 접근할 수 있도록 허용하는 잠금이다. 즉, 여러 프로세스가 공유 자원에 접근할 때 사용된다.
3. **이벤트**
    - 특정 사건이 발생했을 때 다른 스레드에게 알리는 메커니즘이다.
    - 예를 들어 하나의 스레드가 작업을 완료했을 때 다른 스레드에게 그사실을 알려주는 방식이다.
4. **세마포어**
    - 한정된 개수의 자원을 여러 스레드가 사용할 때 접근을 제한하는 방법이다.
    - 예를 들어, 동시에3개의 스레드만 접근할 수 있도록 설정할 수 있다.
5. **대기 가능 타이머(Waitable Timer)**
    - 특정 시간이 지나면 대기 중인 스레드를 깨우는 기능이다.
    - 이 기능을 통해 스레드는 특정 시간 동안 대기하다가 작업을 재개할 수 있다.

**정리…**

- 동기화는 멀티스레드 환경에서 데이터의 무결성을 유지하기 위한 필수적인 부분이다.
- 임계 영역과 잠금을 통해 스레드 간의 충돌을 방지하고 다양한 동기화방법(이벤트, 뮤텍스, 세마포어 등등..)을 사용하여 자원 접근을 효율적으로 관리할 수 있다.
- 이러한 매커니즘을 통해 프로그램의 안정성과 신뢰성을 높일 수 있다.

## synchronized 활용

synchronized는 멀티스레딩 환경에서 임계 영역을 설정하는 데 사용된다.

즉, 여러 스레드가 동시에 접근할 수 없는 코드 블록을 만들기 위해 사용된다. 이를 통해 데이터의 무결성을 유지할 수 있다.

```java
public synchronized void saveMoney(int save) { // 입금
    int m = money;
    try {
        Thread.sleep(2000); // 2초 지연
    } catch (Exception e) {
    }
    money = m + save;
    System.out.println("입금 처리");
}

public synchronized void minusMoney(int minus) { // 출금
    int m = money;
    try {
        Thread.sleep(3000); // 3초 지연
    } catch (Exception e) {
    }
    money = m - minus;
    System.out.println("출금 완료");
}
```

- 위의 saveMoney와 minusMoney 메소드는synchronized 키워드로 동기화 되어있다.
- 이 메소드들은 동시에 하나의 스레드만 접근할 수 있으므로 데이터의 일관성을 유지할 수 있다.
- 예를 들어, 두 개의 스레드가 동시에 입금과 출금을 시도하면, synchronized 덕분에 한 스레드만 작업을 수행하고 다른 스레드는 대기하게 된다.

## wait()과 notify() 활용

스레드 간의 협력 관계를 처리하기 위해 wait()이나 notify() 메소드를 사용한다.

이 메소드들은 스레드가 특정 조건을 만족할때까지 기다리거나, 대기 중인 스레드들을 깨우는 역할을 한다.

**wait()과 notify()?**

wait()

- 스레드가 현재 가지고 있는 잠금을 반납하고 대기 상태로 전환한다.
- 이때 다른 스레드가 잠금을 얻어 임계 영역에 접근할 수 있게 된다.

notify()

- 대기 중인 스레드 중 하나를 깨워서 잠금을 다시 얻도록 한다.
- 즉, 대기 상태에서 실행 가능한 상태로 바꾼다.

```java
public synchronized void makeBread() {
    if (breadCount >= 10) {
        try {
            System.out.println("빵 생산 초과");
            wait(); // 대기 상태로 전환(Thread를 Runnable 상태로 전환)
        } catch (Exception e) {
        }
    }
    breadCount++; // 빵 생산
    System.out.println("빵을 만듦. 총 " + breadCount + "개");
    notify(); // 대기 중인 스레드에게 알림(Thread를 Runnable 상태로 전환) 
}

public synchronized void eatBread() {
    if (breadCount < 1) {
        try {
            System.out.println("빵이 없어 기다림");
            wait(); // 대기 상태로 전환
        } catch (Exception e) {
        }
    }
    breadCount--; // 빵 소비
    System.out.println("빵을 먹음. 총 " + breadCount + "개");
    notify(); // 대기 중인 스레드에게 알림
}
```

- makeBread() 메소드는 빵이 10개 이상일경우 더 이상 만들 수 없으므로 wait()을 호출하여 대기 상태로 전환한다.
- 반대로 eatBread() 메소드는 빵이 없을 경우 대기한다.
- 조건이 반족될 때(빵이 생기거나 or 빵을 먹을 때) notify()를 호출하여 대기 중인 스레드를 깨우게 된다.  
<br>

**문제) 빈칸에 들어갈 알맞은 말을 적으세요.**

- 자바에서 스레드를 구현할때에는 (1)를 구현하는 방법과 (2)를 상속받는 방법, 2가지가 있다.
- 스레드의 상태 중 스레드가 실행 중 또는 실행 가능한 상태는 (3)이다.
- 멀티스레드 프로그래밍에서 여러 스레드가 같은 자원을 동시에 접근하고 수정할 때 서로의 작업이 영향을 주지 않도록 하는 것을 (4)라고 한다.
- 공유 자원에 접근하는 코드 블록을 (5)라고 하고, 이곳에서는 오직하나의 스레드만 접근 가능하다.
- (5)에 접근하기 위해서 사용하는 매커니즘인 (6)을 가진 스레드만 (5) 영역에 접근할수 있다.

  



---

[[Java] 자바 - Thread란? 스레드 개념 및 사용방법](https://kadosholy.tistory.com/121)