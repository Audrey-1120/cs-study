## 값에 의한 호출(Call by Value) & 참조에 의한 호출(Call by reference)

## 값에 의한 호출 (Call by Value)

값에 의한 호출은 함수(또는 메소드)가 호출될 때 매개변수로 전달되는 값의 복사본이 전달되는 방식

- 함수 내에서 매개변수 값이 변경되어도 호출한 쪽의 변수 값은 변경되지 않음.

```java
void func(int n) {
    n = 20;
}

public static void main(String[] args) {
    int n = 10;
    func(n);
    System.out.println(n); // 출력 결과: 10
}
```

- func 함수가 호출될 때 함수를 위한 별도의 임시 공간이 메모리에 생성됨.
    - 이 공간에서 함수가 실행되며 함수가 종료되면 해당 공간은 사라진다.
- 값에 의한 호출 방식은 함수를 호출할 때 전달되는 변수의 값을 복사해서 함수의 인자로 전달한다는 의미이다. 다시 말해서, 함수 내부에서 사용되는 n 변수는 main함수에서 선언된 n 변수와는 다른 변수이다.
- 함수 내부에서 n = 20; 이 실행되면 함수 내부의 n 변수 값이 20으로 변경된다. 그러나 이것은 함수 내부에서만 적용되는 변경이고, main함수에서 선언된 n 변수의 값은 변경되지 않음.
- 따라서 마지막에 printf(”%d”, n)을 실행하면 main 함수에서 선언된 n 변수의 값인 10이 출력됨.

## 참조에 의한 호출 (Call by Reference)

참조에 의한 호출은 함수가 호출될 때 매개변수로 전달되는 변수의 참조(주소)가 전달되는 방식이다.

- 함수 내에서 매개변수 값을 변경하면 호출한 쪽의 변수 값도 함께 변경되는 특징이 있다.

```java
void func(int[] arr) {
    arr[0] = 20;
}

public static void main(String[] args) {
    int[] arr = {10};
    func(arr);
    System.out.println(arr[0]); // 출력 결과: 20
}
```

- main 메소드에서 int[] arr = {10};으로 길이가 1인 배열을 생성하고 첫번 째 요소 값을 10으로 초기화한다.
- func 함수를 호출할 때 배열 arr의 주소값이 전달된다. 이는 참조에 의한 호출이다.
- func 메소드 내부에서 arr[0] = 20; 이 실행된다. 이때 arr 배열의 첫번째 요소 값이 20으로 변경된다.
- func 메소드가 종료되어도 main 메소드의 arr 배열 객체는 변경된 상태로 유지된다.
- 마지막에 System.out.println(arr[0]);을 실행하면 arr 배열의 첫번째 요소값인 20이 출력됨.
- 이처럼 배열을 함수의 인자로 전달할 때는 call by reference 방식이 사용됨.

## 자바에서의 기본적인 호출 방식

자바에서는 기본적으로 값에 의한 호출을 따른다. 

- 그러나 객체를 매개변수로 전달할 때는 해당 객체의 참조가 전달되어 참조에 의한 호출과 유사한 효과를 얻을 수 있음.
- 그래서 객체의 상태를 변경할 수 있고, 이는 호출한 쪽에서도 반영될 수 있음.

**예시 코드를 통해 이해해보자**

```java
User a = new User("Audrey");   

foo(a);

public void foo(User b){        
    b = new User("James");
}
```

1. User a = new User("Audrey"); 에서는 새로운 User 객체를 생성하고, 그 객체의 주소값을 a 변수에 저장한다. 
2. foo(a); 메서드를 호출할 때, a 변수가 가리키고 있는 User 객체의 주소값이 foo() 메서드의 b 파라미터로 전달된다.
3. foo() 메서드 내부에서 b = new User("James");을 실행하면, 새로운 User 객체가 생성되고 그 주소값이 b 변수에 저장된다.
    - 여기서 헷갈릴만한 부분… 처음 foo() 메소드의 파라미터 b는 a 변수가 가리키고 있는 User 객체의 주소값을 전달받는다. 따라서 a와 b는처음에는 같은 User 객체(name=”Audrey”)를 가리킨다.
    - 그런데 foo 메소드 내부의 b = new User(”James”)를 실행하면 b가 새로운 User 객체(name=”James)를 가리키도록 변경된다. 이때 a는 여전히 처음에 생성된 User 객체(name=”Audrey”)를 가리키고 있다. 즉, a와 b가 가리키고 있는 객체가 서로 다른 것이다.
4. 하지만 이것은 a 변수가 가리키고 있는 객체와는 별개의 객체이다.
5. foo() 메서드가 종료되면 b 변수는 사라지지만, a 변수는 여전히 처음에 생성된 User 객체를 가리키고 있다.

상세설명)

- foo() 메소드가 종료되면 b 변수는 사라진다. 그러나 b 변수가 가리키고 있던 새로운 User 객체(name=” James”)는 여전히 메모리에 존재한다.
- a 변수는 여전히 처음에 생성된 User 객체(name = “Audrey”)를 가리키고 있다.
- 이처럼 Java에서는 객체의 주소값이 전달되는 것이 맞다. 그러나 이것은 참조에 의한 호출(call by reference)과는 다르다.
- 참조에 의한 호출은 함수 내부에서 객체의 내용을 변경하면 호출한 쪽의 객체 내용도 변경된다. 하지만 Java에서는 함수 내부에서 객체의 주소값을 변경해도 호출한 쪽의 객체는 변경되지 않는다.
- 따라서 Java의 경우 객체의 주소값이 전달되는 것이지만 값에 의한 호출(call by value)라고 말한다.
- 정리하자면, Java에서는 객체의 주소값이 전달되지만 그 주소값을 이용해 객체의 내용을 변경할 수는 없다.

파라미터에 객체/값의 주소값을 복사하여 넘겨주는 방식을 사용하고 있는 Java는 주소값을 넘겨 주소값에 저장되어 있는 값을 사용하는 call by reference라고 오해할 수 있음.

-> 이는 C/C++과 Java에서 변수를 할당하는 방식으로 이해할 수 있음.

## C, C++과 Java의 변수 할당 방식

```java
// c/c++ 
 
 int a = 10;
 int b = a;
 
 cout << &a << ", " << &b << endl; // out: 0x7ffeefbff49c, 0x7ffeefbff498
 
 a = 11;
 
 cout << &a << endl; // out: 0x7ffeefbff49c

//java
 
 int a = 10;
 int b = a;
 
 System.out.println(System.identityHashCode(a));    // out: 1627674070
 System.out.println(System.identityHashCode(b));    // out: 1627674070
 
 a = 11;

 System.out.println(System.identityHashCode(a));    // out: 1360875712
```

C/C++ 에서는 생성한 변수마다 새로운 메모리 공간을 할당하고 이에 값을 덮어씌우는 형식으로 값을 할당한다. 

Java에서 생성한 변수마다 새로운 메모리 공간을 갖는 건 동일하다. 

- 그러나 그 메모리 공간에 값 자체를 저장하는 것이 아닌, 해당 값을 다른 메모리 공간에 할당하고 이 주소값을 저장한다.

```java

  C/C++        |        Java
               |
a -> [ 10 ]    |   a -> [ XXXX ]     [ 10 ] -> XXXX(위치)
b -> [ 10 ]    |   b -> [ XXXX ]
               |
             값 변경
a -> [ 11 ]    |   a -> [ YYYY ]     [ 10 ] -> XXXX(위치)
b -> [ 10 ]    |   b -> [ XXXX ]     [ 11 ] -> YYYY(위치)
```

- 위의 코드를 보면 b=a;일때 a의 값을 b의 값으로 덮어씌우는 것은 같다.
- 그러나 C/C++은 실제값을 저장하고 있고, Java는 값의 주소값을 저장하고 있다.

즉, Java에서의 변수는 [할당된 값의 위치]를 [값]으로 가지고 있다.

C/C++ 에서는 주소값 자체를 인자로 넘겼을 때 값을 변경하면 새로운 값으로 덮어쓰여져서 기존 값이 변경된다. 그러나 Java에서는 주소값이 덮어쓰여지므로 원본 값은 전혀 영향이 가지 않는다. 

이때 객체의 속성값에 접근하여 변경하는 것은 직접 접근하여 변경하는 것이므로 이를 가리키는 변수들에게서 변경이 일어난다.

```java

객체 접근하여 속성값 변경

a : [ XXXX ]  [ Object [prop : ~ ] ] -> XXXX(위치)
b : [ XXXX ]

prop : ~ (이 또한 변수이므로 어딘가에 ~가 저장되어있고 prop는 이의 주소값을 가지고 있는 셈)
prop : [ YYYY ]    [ ~ ] -> YYYY(위치)

a.prop = * (a를 통해 prop를 변경) 

prop : [ ZZZZ ]    [ ~ ] -> YYYY(위치)
                   [ * ] -> ZZZZ

b -> Object에 접근 -> prop 접근 -> ZZZZ
```

- 먼저 객체의 주소값이 a라는 변수에 저장되어 있다. b=a이므로, b에도 a 변수에 들어있는 주소값이 들어가게 된다.
- 이때 prop : ~ 여기서 prop또한 변수이므로 다른 메모리 영역에 ~값이 저장되어 있고, prop에는 이 주소값을 가지고 있다고 보면 된다.
- a.prop에서는 a를 통해 prop을 변경한다. 그러면 prop에는 새로운 주소값인 ZZZZ로 새롭게 덮어씌워진다. → 원본값인 ~값은 변경되지 않는다.
- 그렇다면 이때 b에서 Object에 접근할 때는 변경된 prop에 저장되어 있는 주소값 ZZZZ을 얻게된다.

다시 말해, 객체의 속성값에 직접 접근하여 변경하면 해당 객체를 가리키는 모든 변수들에게 변경이 반영된다. Java에서는 객체의 주소값이 아닌 객체 자체가 전달되기 때문에 a와 b가 같은 객체를 가리키고 있다면 a를 통해 객체의 속성 변경 시 b에서도 그 변경사항이 전달된다. 즉, 객체의 속성에 직접 접근하여 값을 변경하면 해당 객체를 참조하는 모든 변수들에게 그 변경 사항이 반영된다.

## 정리

**Java는 기본적으로 call by value 방식을 사용**한다.

- **기본 타입 변수를 매개변수로 전달**할 시 **값의 복사본이 전달되므로 call by value**이다.
- **객체 타입 변수를 매개변수로 전달**할 시 객체의 주소값이 전달되므로 call by reference 처럼 보인다.
    - 그러나 **실제로는 객체의 주소값이 복사되어 전달되는 것이므로 call by value**이다.

그런데 **객체의 속성에 직접 접근하여 값을 변경**할때는 조금 다르다.

- 객체의 속성에 직접 접근하여 값을 변경하면 **해당 객체를 참조하는 모든 변수에서 변경 사항이 반영**된다.
- 이는 **객체 자체가 전달**되고 있기 때문에 이런 점에서 call by reference와 유사한 동작을 보인다.


