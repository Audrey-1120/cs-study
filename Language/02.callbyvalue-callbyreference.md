## 값에 의한 호출(Call by Value) & 참조에 의한 호출(Call by reference)

## 값에 의한 호출 (Call by Value)

값에 의한 호출은 함수(또는 메소드)가 호출될 때 매개변수로 전달되는 값의 복사본이 전달되는 방식

- 함수 내에서 매개변수 값이 변경되어도 호출한 쪽의 변수 값은 변경되지 않음.

```java
void func(int n) {
    n = 20;
}

public static void main(String[] args) {
    int n = 10;
    func(n);
    System.out.println(n); // 출력 결과: 10
}
```

- func 함수가 호출될 때 함수를 위한 별도의 임시 공간이 메모리에 생성됨.
    - 이 공간에서 함수가 실행되며 함수가 종료되면 해당 공간은 사라진다.
- 값에 의한 호출 방식은 함수를 호출할 때 전달되는 변수의 값을 복사해서 함수의 인자로 전달한다는 의미이다. 다시 말해서, 함수 내부에서 사용되는 n 변수는 main함수에서 선언된 n 변수와는 다른 변수이다.
- 함수 내부에서 n = 20; 이 실행되면 함수 내부의 n 변수 값이 20으로 변경된다. 그러나 이것은 함수 내부에서만 적용되는 변경이고, main함수에서 선언된 n 변수의 값은 변경되지 않음.
- 따라서 마지막에 printf(”%d”, n)을 실행하면 main 함수에서 선언된 n 변수의 값인 10이 출력됨.

## 참조에 의한 호출 (Call by Reference)

참조에 의한 호출은 함수가 호출될 때 매개변수로 전달되는 변수의 참조(주소)가 전달되는 방식이다.

- 함수 내에서 매개변수 값을 변경하면 호출한 쪽의 변수 값도 함께 변경되는 특징이 있다.

```java
void func(int *n) {
    *n = 20;
}

void main() {
    int n = 10;
    func(&n);
    printf("%d", n);
}
```

- main() 함수에서 int n = 10; 으로 변수 n을 선언하고 초기값 10을 할당한다.
- func(&n);에서의 n의 주소값 &n을 func()함수에 전달한다. 이것이 참조에 의한 호출이다.
- func(int *n)함수에서는 *n = 20;으로 n이 가리키는 메모리 공간의 값을 20으로 변경한다.
- main() 함수로 돌아와서 printf("%d", n);을 실행하면 n의 값이 20으로 출력된다.

## 자바에서의 기본적인 호출 방식

자바에서는 기본적으로 값에 의한 호출을 따른다. 

- 자바에서 함수를 호출할 때, 기본 데이터형(primitive type)인 경우 값이 복사되어 전달되고, 참조 데이터 형(reference type)인 경우 참조값(주소값)이 전달된다.
    - 기본 데이터 형(int, double, boolean 등)
        - 함수 호출 시 변수의 값이 복사되어 전달됨.
        - 함수 내부에서 매개변수 값을 변경해도 호출한 곳의 변수 값은 변경되지 않음.
    - 참조 데이터 형(배열, 클래스 등)
        - 함수 호출 시 변수가 가리키는 참조값(주소값)이 전달된다.
        - 함수 내부에서 매개변수 값을 변경하면 호출한 곳의 변수 값도 변경된다.
- 따라서 자바에서는 기본적으로 값에 의한 호출 방식을 사용하지만 참조 데이터형의 경우 참조값이 전달되어 참조에 의한 호출과 유사한 동작을 한다.

**예시 코드를 통해 이해해보자**

```java
User a = new User("Audrey");   

foo(a);

public void foo(User b){        
    b = new User("James");
}
```

1. User a = new User("Audrey"); 에서는 새로운 User 객체를 생성하고, 그 객체의 주소값을 a 변수에 저장한다. 
2. foo(a); 메서드를 호출할 때, a 변수가 가리키고 있는 User 객체의 주소값이 foo() 메서드의 b 파라미터로 전달된다.
3. foo() 메서드 내부에서 b = new User("James");을 실행하면, 새로운 User 객체가 생성되고 그 주소값이 b 변수에 저장된다.
    - 여기서 헷갈릴만한 부분… 처음 foo() 메소드의 파라미터 b는 a 변수가 가리키고 있는 User 객체의 주소값을 전달받는다. 따라서 a와 b는처음에는 같은 User 객체(name=”Audrey”)를 가리킨다.
    - 그런데 foo 메소드 내부의 b = new User(”James”)를 실행하면 b가 새로운 User 객체(name=”James)를 가리키도록 변경된다. 이때 a는 여전히 처음에 생성된 User 객체(name=”Audrey”)를 가리키고 있다. 즉, a와 b가 가리키고 있는 객체가 서로 다른 것이다.
4. 하지만 이것은 a 변수가 가리키고 있는 객체와는 별개의 객체이다.
5. foo() 메서드가 종료되면 b 변수는 사라지지만, a 변수는 여전히 처음에 생성된 User 객체를 가리키고 있다.

상세설명)

- foo() 메소드가 종료되면 b 변수는 사라진다. 그러나 b 변수가 가리키고 있던 새로운 User 객체(name=” James”)는 여전히 메모리에 존재한다.
- a 변수는 여전히 처음에 생성된 User 객체(name = “Audrey”)를 가리키고 있다.
- 이처럼 Java에서는 객체의 주소값이 전달되는 것이 맞다. 그러나 이것은 참조에 의한 호출(call by reference)과는 다르다.
- 참조에 의한 호출은 함수 내부에서 객체의 내용을 변경하면 호출한 쪽의 객체 내용도 변경된다. 하지만 Java에서는 함수 내부에서 객체의 주소값을 변경해도 호출한 쪽의 객체는 변경되지 않는다.
- 따라서 Java의 경우 객체의 주소값이 전달되는 것이지만 값에 의한 호출(call by value)라고 말한다.
- 정리하자면, Java에서는 객체의 주소값이 전달되지만 그 주소값을 이용해 객체의 내용을 변경할 수는 없다.

파라미터에 객체/값의 주소값을 복사하여 넘겨주는 방식을 사용하고 있는 Java는 주소값을 넘겨 주소값에 저장되어 있는 값을 사용하는 call by reference라고 오해할 수 있음.

-> 이는 C/C++과 Java에서 변수를 할당하는 방식으로 이해할 수 있음.

## C, C++과 Java의 변수 할당 방식

```java
// c/c++ 
 
 int a = 10;
 int b = a;
 
 cout << &a << ", " << &b << endl; // out: 0x7ffeefbff49c, 0x7ffeefbff498
 
 a = 11;
 
 cout << &a << endl; // out: 0x7ffeefbff49c

//java
 
 int a = 10;
 int b = a;
 
 System.out.println(System.identityHashCode(a));    // out: 1627674070
 System.out.println(System.identityHashCode(b));    // out: 1627674070
 
 a = 11;

 System.out.println(System.identityHashCode(a));    // out: 1360875712
```

C/C++ 에서는 생성한 변수마다 새로운 메모리 공간을 할당하고 이에 값을 덮어씌우는 형식으로 값을 할당한다. 

Java에서 생성한 변수마다 새로운 메모리 공간을 갖는 건 동일하다. 

- 그러나 그 메모리 공간에 값 자체를 저장하는 것이 아닌, 해당 값을 다른 메모리 공간에 할당하고 이 주소값을 저장한다.

```java

  C/C++        |        Java
               |
a -> [ 10 ]    |   a -> [ XXXX ]     [ 10 ] -> XXXX(위치)
b -> [ 10 ]    |   b -> [ XXXX ]
               |
             값 변경
a -> [ 11 ]    |   a -> [ YYYY ]     [ 10 ] -> XXXX(위치)
b -> [ 10 ]    |   b -> [ XXXX ]     [ 11 ] -> YYYY(위치)
```

- 위의 코드를 보면 b=a;일때 a의 값을 b의 값으로 덮어씌우는 것은 같다.
- 그러나 C/C++은 실제값을 저장하고 있고, Java는 값의 주소값을 저장하고 있다.

즉, Java에서의 변수는 [할당된 값의 위치]를 [값]으로 가지고 있다.

C/C++ 에서는 주소값 자체를 인자로 넘겼을 때 값을 변경하면 새로운 값으로 덮어쓰여져서 기존 값이 변경된다. 그러나 Java에서는 주소값이 덮어쓰여지므로 원본 값은 전혀 영향이 가지 않는다. 

이때 객체의 속성값에 접근하여 변경하는 것은 직접 접근하여 변경하는 것이므로 이를 가리키는 변수들에게서 변경이 일어난다.

```java

객체 접근하여 속성값 변경

a : [ XXXX ]  [ Object [prop : ~ ] ] -> XXXX(위치)
b : [ XXXX ]

prop : ~ (이 또한 변수이므로 어딘가에 ~가 저장되어있고 prop는 이의 주소값을 가지고 있는 셈)
prop : [ YYYY ]    [ ~ ] -> YYYY(위치)

a.prop = * (a를 통해 prop를 변경) 

prop : [ ZZZZ ]    [ ~ ] -> YYYY(위치)
                   [ * ] -> ZZZZ

b -> Object에 접근 -> prop 접근 -> ZZZZ
```

- 변수 a와 b는 모두 같은 객체를 참조하고 있다.
- 객체 내부에는 prop라는 속성이 있고, 이 속성에는 ~라는 값이 저장되어 있다.
- prop 속성은 하나의 변수이며, 이 변수의 값은 YYYY이다. (~을 가리키고 있는 주소값)
- a.prop = *을 통해 prop 속성의 값을 *으로 변경한다.이때 prop 변수의 값이 ZZZZ로 변경된다.
    - 이는 a를 통해 객체의 prop 속성을 직접 변경했기 때문이다.
- 이후 b를 통해 객체의 prop 속성에 접근하면 ZZZZ 값이 반환된다.
    - 이는 a를 통해 객체의 prop 속성이 변경되었기 때문이다.

즉, 객체의 속성값에 직접 접근하여 변경하면 해당 객체를 참조하고 있는 모든 변수에서 변경 사항이 반영된다. 이는 Java에서 객체가 참조에 의해 전달되기 때문이다.

## 정리

**Java는 기본적으로 call by value 방식을 사용**한다.

- **기본 타입 변수를 매개변수로 전달**할 시 **값의 복사본이 전달되므로 call by value**이다.
- **객체 타입 변수를 매개변수로 전달**할 시 객체의 주소값이 전달되므로 call by reference 처럼 보인다.
    - 그러나 **실제로는 객체의 주소값이 복사되어 전달되는 것이므로 call by value**이다.

그런데 **객체의 속성에 직접 접근하여 값을 변경**할때는 조금 다르다.

- 객체의 속성에 직접 접근하여 값을 변경하면 **해당 객체를 참조하는 모든 변수에서 변경 사항이 반영**된다.
- 이는 **객체 자체가 전달**되고 있기 때문에 이런 점에서 call by reference와 유사한 동작을 보인다.

---
문제) 다음중 빈칸에 들어갈 말을 넣으세요.  
> 보기 : 값에 의한 호출(call by value), 참조에 의한 호출(call by reference)  

Java는 기본적으로 (&emsp;)방식을 사용한다. 이때 객체 타입 변수를 매개변수로 전달할 시 객체의 주소값이 전달되므로 (&emsp;)방식과 유사한 효과를 가져온다. 그러나 실제로는 객체의 주소값이 복사되어 전달되는 것이므로 (&emsp;)이다.